public class MyOperator
{
	public static void main(String[] args) 
	{
		System.out.println("1. 산술연산자(+,-,*,/,%)-----");
		int a=10;
		System.out.println("a*3="+(a*3)); //곱하기
		System.out.println("a/3="+(a/3)); //나눈 몫을 구한다.
		System.out.println("a%3="+(a%3)); //나머지값을 구한다.

		System.out.println("42<<2="+(42<<2)); // 제일 왼쪽에 있는 숫자 2개를 없애고 제일 오른쪽에 숫자2개를 0으로 채운다.
		System.out.println("42>>2="+(42>>2));
		System.out.println("42>>>2="+(42>>>2));
		/* shift 연산자
		1) << : 왼쪽으로 비트수 만큼 이동한다.
				오른쪽에 남은 빈칸은 0으로 채운다.
		2) >> : 오른쪽으로 비트수 만큼 이동한다.
				왼쪽에 남은 빈칸은 부호비트로 채운다.
		3) >>>: 오른쪽으로 비트수만큼 이동한다.
				왼쪽에 남은 빈칸은 무조건 0으로 채운다.
		*/
		// 42: 00000000 00000000 00000000 00101010

		//-43: 11111111 11111111 11111111 11010101
		//다음의 출력 결과를 예상하시오
		System.out.println("-43<<3="+(-43<<3));
		System.out.println("-43>>3="+(-43>>3));
		System.out.println("-43>>>3="+(-43>>>3));

		//-8>>2
		/* 음수값을 비트로 표현하는 방법
			1) 먼저 양수의 값을 비트로 변화해본다.
			   8 : 00000000 00000000 00000000 00001000
			2) 1의 보수를 구한다.(비트반전)
				   11111111 11111111 11111111 11110111
			3) 2의 보수를 구한다. (1의 보수값에 더하기 1을 한다.)
			       11111111 11111111 11111111 11111000
		
		tip) 1) 먼저 양수값의 비트를 구한다.
			 2) 양수값의 하위 비트에서 첫 번째 1을 만날때 까지는 양수와 동일하게 첫번째 1을 만난
				상위비트는 비트 반전을 한다.

				문제 -54를 비트로 바꿔보라
				54 : 00000000 00000000 00000000 00110110
				11111111 11111111 11111111 11001010
		*/
		//java.lang.Integer클래스의 메소드
		System.out.println(Integer.toBinaryString(54));
		System.out.println(Integer.toBinaryString(-54));
	}
}
